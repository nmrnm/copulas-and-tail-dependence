---
title: "Population Simulation"
output: 
  html_document:
      theme: united
      css: style.css
      fig_caption: true
params:
  n: 10000
  dim: 10 
  rho: 0.1
  thresh_hi: 0.7
  thresh_lo: 0.0
  
  r: 1 
  numSimulations: 1
  initPopSize: 500 
  carryingCapacity: 500 
  timeSteps: 200 
  
  filename: "testtext"
  fileext: ".txt"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F, cache = F, fig.align = 'center')
```

```{r, message = F}
library(copula)
library(mvtnorm)
library(ggplot2)
library(tseries)
library(forecast)
```

```{r, functions}
#dr. reuman's function
newCopulaWithTailDependece<-function(n,dim,rho,thresh_lo,thresh_hi)
{
  U<-runif(n)
  ncop<-normalCopula(rho,dim=dim) #this is the copula of a multivariate normal with covariance matrix having 1s on
  #the diagonal and all rhos in all off-diagonal positions
  res<-rCopula(n,ncop)
  res<-(thresh_hi-thresh_lo)*res+thresh_lo
  res[U>thresh_hi,]<-rep(U[U>thresh_hi],times=dim) #this line takes the rows of res for which the corresponding
  #entry of U is bigger than thresh_hi and replaces both entries of those rows by the corresponding value of U
  res[U<thresh_lo,]<-rep(U[U<thresh_lo],times=dim) #this line takes the rows of res for which the corresponding
  #entry of U is smaller than thresh_lo and replaces both entries of those rows by the corresponding value of U
  return(res)
}


findNormalCopulaParam <- function(dim,varSumRetain){
    fOptim <-function(rho){
     #varSum is the sum of all entries in the covariance matrix 
     # and the below formula gets that sum in a closed formula way
     varSum <- dim*(dim-1)*rho + dim
     return(abs(varSum-varSumRetain))
    }
    # $minimum is the x value for which the minimum is achieved (note that optimize returns a list) 
    return(optimize(fOptim,c(0,1),lower=0,upper=1,maximum=FALSE)$minimum)
}
```
# Initial Values
These are the parameters to construct our copula with tail dependence for which we obtain our environmental noise.

<b>n:</b> `r params$n`<br />
<b>dim:</b> `r params$dim`<br />
<b>rho:</b> `r params$rho`<br />
<b>thresh_hi:</b> `r params$thresh_hi`<br />
<b>thresh_lo:</b> `r params$thresh_lo`<br />

These are the values that we have when we simulate our population throughout time.

<b>r:</b> `r params$r`<br />
<b>numSimulations:</b> `r params$numSimulations`<br />
<b>initPopSize:</b> `r params$initPopSize`<br />
<b>carryingCapacity:</b> `r params$carryingCapacity`<br />
<b>timeSteps:</b> `r params$timeSteps`<br />

This is where we obtain additional information we want to include in our document

<b>filename:</b> `r params$filename` <br />
<b>fileext:</b> `r params$fileext` <br />

```{r, fig.align='center'}
res<-newCopulaWithTailDependece(params$n,params$dim,params$rho,params$thresh_lo,params$thresh_hi)
plot(res[,1],res[,2])
res<-qnorm(res)
hist(res[,1],50)
hist(res[,2],50)
```

`r con=file(paste0(getwd(),"/testhtml/",params$filename,params$fileext));lines=readLines(con,n=-1)`
`r lines`
```{r, random variables}

covMatrix <- matrix(data=rep(0,times=params$dim*params$dim),nrow=params$dim,byrow=TRUE)
for(i in 1:params$dim){
  for(j in 1:(params$dim)){
   covMatrix[i,j] <- cov(res[,i],res[,j])
  }
}
varSumRetain <- sum(covMatrix)


rho <- findNormalCopulaParam(params$dim, varSumRetain)
newNormalCop <- normalCopula(param = rho,dim =params$dim)
newNormCop <- rCopula(params$n, newNormalCop)
newMultiNormMarg <- qnorm(newNormCop)
com_mat <- matrix(data=replicate(n=params$dim,res[,1]),ncol=params$dim)


new_sum_res <- rowSums(newMultiNormMarg)
sum_res <- rowSums(res)
sum_com <- params$dim*res[,1] # or rowSums(com_mat) is equivalent

hist(sum_com,50)
var(sum_com)
hist(sum_res,50)
var(sum_res)
hist(new_sum_res,50)
var(new_sum_res)
```

`r con=file(paste0(getwd(),"/testhtml/",params$filename,params$fileext));lines=readLines(con,n=-1)`
`r lines`
```{r, ecdfplot}
valuesV <- append(append(sum_com, sum_res),new_sum_res)
typeV <- rep("sum_com",params$n)
typeV <- append(typeV, rep("sum_res",params$n))
typeV <- append(typeV, rep("new_sum_res",params$n))


dataFrame <- data.frame(values = valuesV, type = typeV)

ecdfPlot <- ggplot(dataFrame, aes( x= unlist(dataFrame[1]) ) )
ecdfPlot <- ecdfPlot + stat_ecdf(mapping=aes(color=type))
ecdfPlot <- ecdfPlot + labs(title = "Empirical Cumulative \n Density Function")
ecdfPlot <- ecdfPlot +  xlab("Random variable value")
ecdfPlot <- ecdfPlot +  ylab("Cumulative Density")
ecdfPlot <- ecdfPlot + theme(text = element_text(size=7),
                             legend.box='horizontal',
                             legend.text = element_text(size = 8),
                             panel.background = element_rect(fill = "white")) + scale_colour_brewer(palette = "Set1")
plot(ecdfPlot)
```

`r con=file(paste0(getwd(),"/testhtml/",params$filename,params$fileext));lines=readLines(con,n=-1)`
`r lines`
```{r, epsilon environment var, eval = T,  warning = FALSE}
ricker <-function(curpop,r,k,eps){
  return(curpop*exp(r*(1-(curpop/k))+eps))
}

extinct<-function(pop,tLow,tHigh){
  if(any(pop<tLow|pop>tHigh)){return(TRUE)}
  return(FALSE)
}


tLow <- params$initPopSize/2 
tHigh <- 2*params$carryingCapacity

numExtinctCom <- 0 
numExtinctRes <- 0 
numExtinctNewRes <- 0 

for(j in 1:params$numSimulations){
  eps_res <- res[sample(nrow(res),size=params$timeSteps,replace=T),] 
  eps_com <- com_mat[sample(nrow(res),size=params$timeSteps,replace=T),] 
  eps_new_res <- newMultiNormMarg[sample(nrow(newMultiNormMarg),size=params$timeSteps,replace=T),] 
  
  popSizeCom <- matrix(data=rep(params$initPopSize,times=params$dim),nrow=1,byrow = T)
  popSizeRes <- matrix(data=rep(params$initPopSize,times=params$dim),nrow=1,byrow = T)
  popSizeNewRes <-  matrix(data=rep(params$initPopSize,times=params$dim),nrow=1,byrow = T)
  
  for(i in 1:(params$timeSteps)){
      popSizeCom <- rbind(popSizeCom,ricker(popSizeCom[i,],params$r,params$carryingCapacity,eps_com[i,]))
      popSizeRes <- rbind(popSizeRes,ricker(popSizeRes[i,],params$r,params$carryingCapacity,eps_res[i,]))
      popSizeNewRes <- rbind(popSizeNewRes,ricker(popSizeNewRes[i,],params$r,params$carryingCapacity,eps_new_res[i,]))
  }
  
  totalPopSizeCom <- rowSums(popSizeCom)/params$dim
  totalPopSizeRes <- rowSums(popSizeRes)/params$dim
  totalPopSizeNewRes <- rowSums(popSizeNewRes)/params$dim
  
  if(extinct(totalPopSizeCom,tLow,tHigh)){numExtinctCom<-numExtinctCom+1}
  if(extinct(totalPopSizeRes,tLow,tHigh)){numExtinctRes<-numExtinctRes+1}
  if(extinct(totalPopSizeNewRes,tLow,tHigh)){numExtinctNewRes<-numExtinctNewRes+1}

  if(j == 1){
    m = max(totalPopSizeCom,totalPopSizeRes,totalPopSizeNewRes) + 1000
    plot.ts(totalPopSizeCom,ylim=c(0,m))
    plot.ts(totalPopSizeRes,ylim=c(0,m))
    plot.ts(totalPopSizeNewRes,ylim=c(0,m))
    
  }
}
```

`r con=file(paste0(getwd(),"/testhtml/",params$filename,params$fileext));lines=readLines(con,n=-1)`
`r lines`
```{r}
mean(eps_com)
mean(eps_res)
mean(eps_new_res)
hist(totalPopSizeCom,200)
print(paste0("mean: ", mean(totalPopSizeCom)," median: ", median(totalPopSizeCom)))
hist(totalPopSizeRes,200)
print(paste0("mean: ", mean(totalPopSizeRes)," median: ", median(totalPopSizeRes)))
hist(totalPopSizeNewRes,200)
print(paste0("mean: ", mean(totalPopSizeNewRes)," median: ", median(totalPopSizeNewRes)))
```

`r con=file(paste0(getwd(),"/testhtml/",params$filename,params$fileext));lines=readLines(con,n=-1)`
`r lines`
```{r}
pacf(totalPopSizeCom)
pacf(totalPopSizeRes)
pacf(totalPopSizeNewRes)
```

`r con=file(paste0(getwd(),"/testhtml/",params$filename,params$fileext));lines=readLines(con,n=-1)`
`r lines`
```{r}
acf(totalPopSizeCom)
acf(totalPopSizeRes)
acf(totalPopSizeNewRes)
```



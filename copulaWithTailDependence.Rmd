---
title: "copulaWithTailDependence"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
```{r}
library(copula)
library(mvtnorm)
library(ggplot2)
```

note that there there is dr.reumans code here as well (see ForNoah20200601.R)
```{r}

newCopulaWithTailDependece<-function(n,dim,rho,thresh_lo,thresh_hi)
{
  U<-runif(n)
  ncop<-normalCopula(rho,dim=dim) #this is the copula of a multivariate normal with covariance matrix having 1s on
  #the diagonal and all rhos in all off-diagonal positions
  res<-rCopula(n,ncop)
  res<-(thresh_hi-thresh_lo)*res+thresh_lo
  res[U>thresh_hi,]<-rep(U[U>thresh_hi],times=dim) #this line takes the rows of res for which the corresponding
  #entry of U is bigger than thresh_hi and replaces both entries of those rows by the corresponding value of U
  res[U<thresh_lo,]<-rep(U[U<thresh_lo],times=dim) #this line takes the rows of res for which the corresponding
  #entry of U is smaller than thresh_lo and replaces both entries of those rows by the corresponding value of U
  return(res)
}


findNormalCopulaParam <- function(numSamples,dim,varSumRetain){
    fOptim <-function(rho){
     #varSum is the sum of all entries in the covariance matrix 
     # and the below formula gets that sum in a closed formula way
     varSum <- dim*(dim-1)*rho + dim
     return(abs(varSum-varSumRetain))
    }
    # $minimum is the x value for which the minimum is achieved (note that optimize returns a list) 
    return(optimize(fOptim,c(0,1),lower=0,upper=1,maximum=FALSE)$minimum)
}

#findCovarianceMatrix(numSamples,dim,varSumRetain){
  # We have covariance matrix where the variance of each of the marginals are given
  # and so with this we can represente every covariance matrices with 1's along the 
  # main diagonal can be represented as a matrix of the form as P^T*P where P is an 
  # orthogonal matrix (so the transpose is equal to its inverse)
  
  
 # return()
  
#}

```


```{r}
n<-10000
dim<-10
rho<-0
thresh_hi<-0.7
thresh_lo<- 0
res<-newCopulaWithTailDependece(n,dim,rho,thresh_lo,thresh_hi)
dim(res)
plot(res[,1],res[,2],type="p")
plot(res[,1],res[,3],type="p")

res<-qnorm(res)
hist(res[,1],50)
hist(res[,2],50)
```

```{r}
covMatrix <- matrix(data=rep(0,times=dim*dim),nrow=dim,byrow=TRUE)
newCovMatrix <- matrix(data=rep(rho, dim*dim), nrow=dim,byrow=TRUE)
varSumRetain <- 0 
# covMatrix is not really needed
# it is the covariance matrix for the marginals of the normal copula when
# the marginals are transformed into normal dist. 

for(i in 1:dim){
  for(j in 1:(dim)){
   if(i == j){
      newCovMatrix[i,i] <- 1
   }
   covMatrix[i,j] <- cov(res[,i],res[,j])
   varSumRetain <- varSumRetain + covMatrix[i,j]
  }
}
```

```{r}

rho <- findNormalCopulaParam(numSamples, dim, varSumRetain)
newNormalCop <- normalCopula(param = rho,dim =dim)
newNormCop <- rCopula(n, newNormalCop)

newMultiNormMarg <- qnorm(newNormCop)

new_sum_of_x1_xn <- newMultiNormMarg[,1]
sum_res <- res[,1]
com <- dim*res[,1]

for(i in 2:dim){
  sum_res <- sum_res + res[,i]
  new_sum_of_x1_xn <- new_sum_of_x1_xn + newMultiNormMarg[,i] 
}
hist(com,50)
var(com)
hist(sum_res,50)
var(sum_res)
hist(new_sum_of_x1_xn,50)
var(new_sum_of_x1_xn)

#plot(res[,1],res[,2],type="p")
#plot(newNormCop[,1],newNormCop[,2])
```

```{r}
valuesV <- append(append(com, sum_res),new_sum_of_x1_xn)
typeV <- rep("com",n)
typeV <- append(typeV, rep("sum_res",n))
typeV <- append(typeV, rep("new_sum_of_x1_xn",n))


dataFrame <- data.frame(values = valuesV, type = typeV)

ecdfPlot <- ggplot(dataFrame, aes( x= unlist(dataFrame[1]) ) )
ecdfPlot <- ecdfPlot + stat_ecdf(mapping=aes(color=type))
ecdfPlot <- ecdfPlot + labs(title = "Empirical Cumulative \n Density Function")
ecdfPlot <- ecdfPlot +  xlab("Random variable value")
ecdfPlot <- ecdfPlot +  ylab("Cumulative Density")
ecdfPlot <- ecdfPlot + theme(text = element_text(size=7),
                             legend.box='horizontal',
                             legend.text = element_text(size = 8),
                             panel.background = element_rect(fill = "white")) + scale_colour_brewer(palette = "Set1")
plot(ecdfPlot)


```

```{r}

timeSteps <- 50
popSize_T_var <- matrix(rep(100, times = 3),nrow=1) # initial population for each of the three cases 
popSize_T_fix <- matrix(rep(100, times = 3),nrow=1)
r <- 0 #growth-rate
carryingCapacity <- 500


# numEps <- timeSteps + 100 
# ecdf_com <- ecdf(com)
# ecdf_sum_res <-ecdf(sum_res)
# ecdf_new_sum_of_x1_xn <- ecdf(new_sum_of_x1_xn)
# epsilon_com <- ecdf_com(sample(com, numEps))
# epsilon_sum_res <- ecdf_sum_res(sample(sum_res,numEps))
# epsilon_new_sum_of_x1_xn <- ecdf_new_sum_of_x1_xn(sample(new_sum_of_x1_xn, numEps))

scale_eps <- 2
```


```{r}
eps_com <- scale_eps*sample(com,timeSteps)/range(com)
eps_sum_res <- scale_eps*sample(sum_res,timeSteps)/range(sum_res)
eps_new_sum_of_x1_xn <- scale_eps*sample(new_sum_of_x1_xn,timeSteps)/range(new_sum_of_x1_xn)

for(i in 1:timeSteps){
  temp <- popSize_T_var[i,1]*exp(r*(1-(popSize_T_var[i,1]/carryingCapacity))+eps_com[i]) 
  temp <- append(temp,popSize_T_var[i,2]*exp(r*(1-(popSize_T_var[i,2]/carryingCapacity))+eps_sum_res[i]) )  
  temp <- append(temp, popSize_T_var[i,3]*exp(r*(1-(popSize_T_var[i,3]/carryingCapacity))+eps_new_sum_of_x1_xn[i]) )   
  popSize_T_var <- rbind(popSize_T_var, temp)
}

popAbund_T_var <- ts(popSize_T_var,names=c("com","sum_res","new_sum_of_x1_xn"))
plot.ts(popAbund_T_var)

for(i in 1:timeSteps){
  temp <- popSize_T_fix[i,1]*exp(r*(1-(popSize_T_fix[i,1]/carryingCapacity))+eps_com[1])   
  temp <- append(temp,popSize_T_fix[i,2]*exp(r*(1-(popSize_T_fix[i,2]/carryingCapacity))+eps_sum_res[1]) )  
  temp <- append(temp, popSize_T_fix[i,3]*exp(r*(1-(popSize_T_fix[i,3]/carryingCapacity))+eps_new_sum_of_x1_xn[1]) )   
  popSize_T_fix <- rbind(popSize_T_fix, temp)
}
print(dim(popSize_T_fix))
print(dim(popSize_T_var))
#print(popSize_T_fix) 
#popAbund_T_fix <- ts(popSize_T_fix,names=c("com","sum_res","new_sum_of_x1_xn"))
#plot.ts(popAbund_T_fix)
```

```{r}
numSimulations <- 10000
numExtinct <- rep(0,times=3)

eps_com <- scale_eps*sample(com,numSimulations)/range(com)
eps_sum_res <- scale_eps*sample(sum_res,numSimulations)/range(sum_res)
eps_new_sum_of_x1_xn <- scale_eps*sample(new_sum_of_x1_xn,numSimulations)/range(new_sum_of_x1_xn)

for(j in 1:numSimulations){
  initPopSize <- 100
  popSize_T <- matrix(rep(initPopSize,3),nrow=1)
  
  if(r*(1-(initPopSize/carryingCapacity))+eps_com[j] < 0){numExtinct[1]<-numExtinct[1]+1} 
  if(r*(1-(initPopSize/carryingCapacity))+eps_sum_res[j] < 0){numExtinct[2]<-numExtinct[2]+1} 
  if(r*(1-(initPopSize/carryingCapacity))+eps_new_sum_of_x1_xn[j] < 0){numExtinct[3]<-numExtinct[3]+1} 
  
}
print(numExtinct)

```

```{r}

numSimulations <- 10000
numExtinct <- rep(0,times=3)

eps_com <- scale_eps*sample(com,numSimulations)/range(com)
eps_sum_res <- scale_eps*sample(sum_res,numSimulations)/range(sum_res)
eps_new_sum_of_x1_xn <- scale_eps*sample(new_sum_of_x1_xn,numSimulations)/range(new_sum_of_x1_xn)

avgPopSize_T <- matrix(rep(0,times=3*(1+timeSteps)),nrow=(timeSteps+1),byrow=T)

for(j in 1:numSimulations){
  initPopSize <- 100
  popSize_T <- matrix(rep(initPopSize,3),nrow=1)

  for(i in 1:timeSteps){
    temp <- popSize_T[i,1]*exp(1-(popSize_T[i,1]/carryingCapacity+eps_com[j]) )
    temp <- append(temp,popSize_T[i,2]*exp(1-(popSize_T[i,2]/carryingCapacity+eps_sum_res[j]) )  )
    temp <- append(temp, popSize_T[i,3]*exp(1-(popSize_T[i,3]/carryingCapacity+eps_new_sum_of_x1_xn[j]) ) )
    popSize_T <- rbind(popSize_T, temp)
  }
  avgPopSize_T <- avgPopSize_T + popSize_T
  
  thres<- function(x){
    thresExt <- popSize_T[1,x]
    return(popSize_T[popSize_T[,x]<thresExt,x])
  }
  
  if(length(thres(1))>0){numExtinct[1]<-numExtinct[1]+1}
  if(length(thres(2))>0){numExtinct[2]<-numExtinct[2]+1}
  if(length(thres(3))>0){numExtinct[3]<-numExtinct[3]+1}
}
avgPopSize_T <- ts(avgPopSize_T/numSimulations,names=c("com","sum_res","new_sum_of_x1_xn"))
plot.ts(avgPopSize_T)

print(numExtinct)

```
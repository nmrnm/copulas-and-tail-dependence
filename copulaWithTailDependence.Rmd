---
title: "copulaWithTailDependence"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
```{r}
library(copula)
library(mvtnorm)
library(ggplot2)
```

```{r}
#dr. reuman's function
newCopulaWithTailDependece<-function(n,dim,rho,thresh_lo,thresh_hi)
{
  U<-runif(n)
  ncop<-normalCopula(rho,dim=dim) #this is the copula of a multivariate normal with covariance matrix having 1s on
  #the diagonal and all rhos in all off-diagonal positions
  res<-rCopula(n,ncop)
  res<-(thresh_hi-thresh_lo)*res+thresh_lo
  res[U>thresh_hi,]<-rep(U[U>thresh_hi],times=dim) #this line takes the rows of res for which the corresponding
  #entry of U is bigger than thresh_hi and replaces both entries of those rows by the corresponding value of U
  res[U<thresh_lo,]<-rep(U[U<thresh_lo],times=dim) #this line takes the rows of res for which the corresponding
  #entry of U is smaller than thresh_lo and replaces both entries of those rows by the corresponding value of U
  return(res)
}


findNormalCopulaParam <- function(numSamples,dim,varSumRetain){
    fOptim <-function(rho){
     #varSum is the sum of all entries in the covariance matrix 
     # and the below formula gets that sum in a closed formula way
     varSum <- dim*(dim-1)*rho + dim
     return(abs(varSum-varSumRetain))
    }
    # $minimum is the x value for which the minimum is achieved (note that optimize returns a list) 
    return(optimize(fOptim,c(0,1),lower=0,upper=1,maximum=FALSE)$minimum)
}
```

```{r}
n<-10000
dim<-10 
rho<-0
thresh_hi<-0.7
thresh_lo<- 0
res<-newCopulaWithTailDependece(n,dim,rho,thresh_lo,thresh_hi)
dim(res)

res<-qnorm(res)
hist(res[,1],50)
hist(res[,2],50)
```

```{r}
covMatrix <- matrix(data=rep(0,times=dim*dim),nrow=dim,byrow=TRUE)

for(i in 1:dim){
  for(j in 1:(dim)){
   covMatrix[i,j] <- cov(res[,i],res[,j])
  }
}

varSumRetain <- sum(covMatrix)
```

```{r}
rho <- findNormalCopulaParam(numSamples, dim, varSumRetain)
newNormalCop <- normalCopula(param = rho,dim =dim)
newNormCop <- rCopula(n, newNormalCop)
newMultiNormMarg <- qnorm(newNormCop)
com_mat <- matrix(data=replicate(n=dim,res[,1]),ncol=dim)


new_sum_res <- rowSums(newMultiNormMarg)
sum_res <- rowSums(res)
sum_com <- dim*res[,1] # or rowSums(com_mat) is equivalent

hist(sum_com,50)
var(sum_com)
hist(sum_res,50)
var(sum_res)
hist(new_sum_res,50)
var(new_sum_res)
```

```{r}
valuesV <- append(append(sum_com, sum_res),new_sum_res)
typeV <- rep("sum_com",n)
typeV <- append(typeV, rep("sum_res",n))
typeV <- append(typeV, rep("new_sum_res",n))


dataFrame <- data.frame(values = valuesV, type = typeV)

ecdfPlot <- ggplot(dataFrame, aes( x= unlist(dataFrame[1]) ) )
ecdfPlot <- ecdfPlot + stat_ecdf(mapping=aes(color=type))
ecdfPlot <- ecdfPlot + labs(title = "Empirical Cumulative \n Density Function")
ecdfPlot <- ecdfPlot +  xlab("Random variable value")
ecdfPlot <- ecdfPlot +  ylab("Cumulative Density")
ecdfPlot <- ecdfPlot + theme(text = element_text(size=7),
                             legend.box='horizontal',
                             legend.text = element_text(size = 8),
                             panel.background = element_rect(fill = "white")) + scale_colour_brewer(palette = "Set1")
plot(ecdfPlot)
```

```{r}
r <- 0 
initPopSize <- 100
carryingCapacity <- 500
timeSteps <- 50

eps_res <- res[1:timeSteps,] 
eps_com <- com_mat[1:timeSteps,]
eps_new_res <- newMultiNormMarg[1:timeSteps,]

```

```{r, fixed function}
# arbitrary function
fix_func <- function(x,alpha){return(alpha*x)} 

#let us say that the population resulting from marginals x1, x2, ... ,xn 
#can be modeled by the functions fix_func with i = alpha where i = 1, 2, ... n
# so we have the following

popSizeCom <- matrix(data=rep(initPopSize,times=dim),nrow=1,byrow = T)
popSizeRes <- matrix(data=rep(initPopSize,times=dim),nrow=1,byrow = T)
popSizeNewRes <-  matrix(data=rep(initPopSize,times=dim),nrow=1,byrow = T)

for(i in 1:(timeSteps)){
    popSizeCom <- rbind(popSizeCom,fix_func(eps_com[i,],i*1:dim))
    popSizeRes <- rbind(popSizeRes,fix_func(eps_res[i,],i*1:dim))
    popSizeNewRes <- rbind(popSizeNewRes,fix_func(eps_new_res[i,],i*1:dim))
}
```

```{r}
comTS <- ts(popSizeCom,names=sprintf("com%s",seq(1:dim)))
resTS <- ts(popSizeRes,names=sprintf("res%s",seq(1:dim)))
newResTS <- ts(popSizeNewRes,names=sprintf("newRes%s",seq(1:dim)))

totalPopSizeCom <- rowSums(popSizeCom)
totalPopSizeRes <- rowSums(popSizeRes)
totalPopSizeNewRes <- rowSums(popSizeNewRes)

sumTS <- ts( matrix(data=cbind(totalPopSizeCom,totalPopSizeRes,totalPopSizeNewRes),ncol=3),
             names=c("totalPopSizeCom","totalPopSizeRes","totalPopSizeNewRes"))

plot.ts(comTS)
plot.ts(resTS)
plot.ts(newResTS)
plot.ts(sumTS,cex.lab=0.8)
```

```{r, epsilon ~ environment var}
ricker <-function(curPop,r,K,eps){
  return(curPop*exp(r*(1-(curPop/K))+eps))
}

popSizeCom <- matrix(data=rep(initPopSize,times=dim),nrow=1,byrow = T)
popSizeRes <- matrix(data=rep(initPopSize,times=dim),nrow=1,byrow = T)
popSizeNewRes <-  matrix(data=rep(initPopSize,times=dim),nrow=1,byrow = T)

for(i in 1:(timeSteps)){
    popSizeCom <- rbind(popSizeCom,ricker(popSizeCom[i,],r,carryingCapacity,eps_com[i,]))
    popSizeRes <- rbind(popSizeRes,ricker(popSizeRes[i,],r,carryingCapacity,eps_res[i,]))
    popSizeNewRes <- rbind(popSizeNewRes,ricker(popSizeNewRes[i,],r,carryingCapacity,eps_new_res[i,]))
}

# covMatPopCom <- matrix(data=rep(0,times=dim*dim),nrow=dim)
# for(i in 1:dim){
#   for(j in 1:dim){
#     covMatPopCom[i,j] <- cov(popSizeCom[,i],popSizeCom[,j])
#   }
# }

```

```{r}
comTS <- ts(popSizeCom,names=sprintf("com%s",seq(1:dim)))
resTS <- ts(popSizeRes,names=sprintf("res%s",seq(1:dim)))
newResTS <- ts(popSizeNewRes,names=sprintf("newRes%s",seq(1:dim)))

totalPopSizeCom <- rowSums(popSizeCom)
totalPopSizeRes <- rowSums(popSizeRes)
totalPopSizeNewRes <- rowSums(popSizeNewRes)

sumTS <- ts( matrix(data=cbind(totalPopSizeCom,totalPopSizeRes,totalPopSizeNewRes),ncol=3),
             names=c("totalPopSizeCom","totalPopSizeRes","totalPopSizeNewRes"))

plot.ts(comTS)
plot.ts(resTS)
plot.ts(newResTS)
plot.ts(sumTS,cex.lab=0.8)
```

```{r}
numSimulations <- 1000
numExtinctCom <- rep(0, times= dim)
numExtinctRes <- rep(0, times= dim)
numExtinctNewRes <- rep(0, times= dim)

asymptPopSizeCom <- matrix(data=rep(0,times=dim*(timeSteps+1)),nrow=timeSteps+1)
asymptPopSizeRes <- matrix(data=rep(0,times=dim*(timeSteps+1)),nrow=timeSteps+1)
asymptPopSizeNewRes <- matrix(data=rep(0,times=dim*(timeSteps+1)),nrow=timeSteps+1)

for(i in 1:numSimulations){
  eps_res <- res[1:timeSteps,] 
  eps_com <- com_mat[1:timeSteps,]
  eps_new_res <- newMultiNormMarg[1:timeSteps,]

  initPopSize <- 100
  popSizeCom <- matrix(data=rep(initPopSize,times=dim),nrow=1,byrow = T)
  popSizeRes <- matrix(data=rep(initPopSize,times=dim),nrow=1,byrow = T)
  popSizeNewRes <-  matrix(data=rep(initPopSize,times=dim),nrow=1,byrow = T)
  
  for(i in 1:(timeSteps)){
      popSizeCom <- rbind(popSizeCom,ricker(popSizeCom[i,],r,carryingCapacity,eps_com[i,]))
      popSizeRes <- rbind(popSizeRes,ricker(popSizeRes[i,],r,carryingCapacity,eps_res[i,]))
      popSizeNewRes <- rbind(popSizeNewRes,ricker(popSizeNewRes[i,],r,carryingCapacity,eps_new_res[i,]))
  }  
  
  asymptPopSizeCom <- asymptPopSizeCom + popSizeCom
  asymptPopSizeRes  <- asymptPopSizeRes + popSizeRes
  asymptPopSizeNewRes  <- asymptPopSizeNewRes + popSizeNewRes
  
  tExt <- initPopSize/2 
  thres<-function(popVec,thresExt){
    return(popVec[popVec<thresExt])
  }
    
  for(i in 1:dim){
    if(length(thres(popSizeCom[,i],tExt))>0){numExtinctCom[i]<-numExtinctCom[i]+1}
    if(length(thres(popSizeRes[,i],tExt))>0){numExtinctRes[i]<-numExtinctRes[i]+1}
    if(length(thres(popSizeNewRes[,i],tExt))>0){numExtinctNewRes[i]<-numExtinctNewRes[i]+1}
  }
}

print(numExtinctCom)
print(numExtinctRes)
print(numExtinctNewRes)
print(mean(numExtinctCom))
print(mean(numExtinctRes))
print(mean(numExtinctNewRes))
print(var(numExtinctCom))
print(var(numExtinctRes))
print(var(numExtinctNewRes))
```

```{r}
# average time series plot after many iterations

asymptPopSizeCom <- asymptPopSizeCom / numSimulations
asymptPopSizeRes  <- asymptPopSizeRes / numSimulations 
asymptPopSizeNewRes  <- asymptPopSizeNewRes /numSimulations 

asymptComTS <- ts(asymptPopSizeCom,names=sprintf("asymptcom%s",seq(1:dim)))
asymptResTS <- ts(asymptPopSizeRes,names=sprintf("asymptres%s",seq(1:dim)))
asymptNewResTS <- ts(asymptPopSizeRes,names=sprintf("asymptnewRes%s",seq(1:dim)))

asymptTotalPopSizeCom <- rowSums(asymptPopSizeCom)
asymptTotalPopSizeRes <- rowSums(asymptPopSizeRes)
asymptTotalPopSizeNewRes <- rowSums(asymptPopSizeNewRes)

asymptSumTS <- ts( matrix(data=cbind(asymptTotalPopSizeCom,asymptTotalPopSizeRes,asymptTotalPopSizeNewRes),ncol=3),
             names=c("asymptTotalPopSizeCom","asymptTotalPopSizeRes","asymptTotalPopSizeNewRes"))

plot.ts(asymptComTS,cex.lab=0.5)
plot.ts(asymptResTS,cex.lab=0.5)
plot.ts(asymptNewResTS,cex.lab=0.5)
plot.ts(asymptSumTS,cex.lab=0.5)
```

